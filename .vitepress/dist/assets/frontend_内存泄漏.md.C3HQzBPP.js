import{_ as e,c as t,o as r,aC as o}from"./chunks/framework.CPK-2qeG.js";const p=JSON.parse('{"title":"内存泄漏","description":"","frontmatter":{"title":"内存泄漏","date":"2024-11-28T13:00:47.000Z","tags":null,"categories":null},"headers":[],"relativePath":"frontend/内存泄漏.md","filePath":"frontend/内存泄漏.md"}'),n={name:"frontend/内存泄漏.md"};function l(i,a,_,d,s,h){return r(),t("div",null,a[0]||(a[0]=[o('<h5 id="_1-意外的全局变量" tabindex="-1">1.意外的全局变量 <a class="header-anchor" href="#_1-意外的全局变量" aria-label="Permalink to &quot;1.意外的全局变量&quot;">​</a></h5><p>无法被回收</p><h5 id="_2-定时器" tabindex="-1">2.定时器 <a class="header-anchor" href="#_2-定时器" aria-label="Permalink to &quot;2.定时器&quot;">​</a></h5><p>未被正确关闭，导致所引用的外部变量无法被释放</p><h5 id="_3-事件监听" tabindex="-1">3.事件监听 <a class="header-anchor" href="#_3-事件监听" aria-label="Permalink to &quot;3.事件监听&quot;">​</a></h5><p>没有正确销毁 (低版本浏览器可能出现)</p><h5 id="_4-闭包" tabindex="-1">4.闭包 <a class="header-anchor" href="#_4-闭包" aria-label="Permalink to &quot;4.闭包&quot;">​</a></h5><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p><h5 id="_5-dom-引用" tabindex="-1">5.dom 引用 <a class="header-anchor" href="#_5-dom-引用" aria-label="Permalink to &quot;5.dom 引用&quot;">​</a></h5><p>dom 元素被删除时，内存中的引用未被正确清空</p><h5 id="_6-控制台" tabindex="-1">6.控制台 <a class="header-anchor" href="#_6-控制台" aria-label="Permalink to &quot;6.控制台&quot;">​</a></h5><p>console.log打印的东西 可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。</p><p><a href="https://juejin.cn/post/6947841638118998029?utm_source=gold_browser_extension" target="_blank" rel="noreferrer">内存泄露排查方法</a></p>',13)]))}const m=e(n,[["render",l]]);export{p as __pageData,m as default};
