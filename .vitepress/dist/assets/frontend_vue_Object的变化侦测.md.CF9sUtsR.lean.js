import{_ as h,C as p,c as k,o as d,j as a,G as e,aC as r,a as l,w as i}from"./chunks/framework.CPK-2qeG.js";const j=JSON.parse('{"title":"Object的变化侦测","description":"","frontmatter":{"title":"Object的变化侦测","date":"2025-03-30T15:13:01.000Z","tags":null,"categories":null},"headers":[],"relativePath":"frontend/vue/Object的变化侦测.md","filePath":"frontend/vue/Object的变化侦测.md"}'),E={name:"frontend/vue/Object的变化侦测.md"};function o(y,s,u,c,g,f){const n=p("a-collapse-panel"),t=p("a-collapse");return d(),k("div",null,[s[5]||(s[5]=a("h2",{id:"前言",tabindex:"-1"},[l("前言 "),a("a",{class:"header-anchor",href:"#前言","aria-label":'Permalink to "前言"'},"​")],-1)),s[6]||(s[6]=a("p",null,"Object 和 Array 的变化 侦测采用不同的处理方式。",-1)),s[7]||(s[7]=a("h2",{id:"什么是变化侦测",tabindex:"-1"},[l("什么是变化侦测 "),a("a",{class:"header-anchor",href:"#什么是变化侦测","aria-label":'Permalink to "什么是变化侦测"'},"​")],-1)),s[8]||(s[8]=a("p",null,"Vue.js 会自动通过状态生成 DOM，并将其输出到页面上显示出来，这个过程叫渲染。Vue.js 的渲染过程是声明式的，我们通过模板来描述状态与 DOM 之间的映射关系。通常，在运行时应用内部的状态会不断发生变化，此时需要不停地重新渲染这时如何确定状态中发生了什么变化？",-1)),e(t,null,{default:i(()=>[e(n,{key:"1",header:"变化侦测就是用来解决这个问题的，它分为两种类型：一种是“推”（push），另一种是“拉”（pull）。Angular和React的变化侦测属于哪种？用什么实现？"},{default:i(()=>s[0]||(s[0]=[a("p",null,"Angular和React中的变化侦测都属于“拉”，这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。 ",-1)])),_:1}),e(n,{key:"2",header:"那么vue的变化侦测是怎么样的呢？"},{default:i(()=>s[1]||(s[1]=[a("p",null,"所谓更细粒度的更新，就是说：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。 ",-1)])),_:1}),e(n,{key:"3",header:"vue是'推'，粒度最细，代价是什么？"},{default:i(()=>s[2]||(s[2]=[a("p",null,"但是它也有一定的代价，因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，从Vue.js2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。 ",-1),a("p",null,"Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。",-1)])),_:1})]),_:1}),s[9]||(s[9]=a("h2",{id:"如何追踪变化",tabindex:"-1"},[l("如何追踪变化 "),a("a",{class:"header-anchor",href:"#如何追踪变化","aria-label":'Permalink to "如何追踪变化"'},"​")],-1)),e(t,null,{default:i(()=>[e(n,{key:"1",header:"在js里怎么侦测一个对象的变化？ES6有什么新的方法？"},{default:i(()=>s[3]||(s[3]=[a("p",null," Object.defineProperty 和ES6的Proxy。",-1)])),_:1})]),_:1}),s[10]||(s[10]=r("",2)),e(t,null,{default:i(()=>[e(n,{key:"1",header:"为什么要设置 enumerable: true,configurable: true？"},{default:i(()=>s[4]||(s[4]=[a("p",null," Object.defineProperty(obj, prop, descriptor)",-1),a("p",null," Object.defineProperty() 允许精确地添加或修改对象上的属性。通过赋值添加的普通属性会在枚举属性时（例如 for...in、Object.keys() 等）出现，它们的值可以被更改，也可以被删除。此方法允许更改这些额外细节，以使其不同于默认值。默认情况下，使用 Object.defineProperty() 添加的属性是不可写、不可枚举和不可配置的。此外，Object.defineProperty() 使用 [[DefineOwnProperty]] 内部方法，而不是 [[Set]]，因此即使属性已经存在，它也不会调用 setter。",-1),a("a",{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#%E6%8F%8F%E8%BF%B0"},"MDN详细资料",-1)])),_:1})]),_:1}),s[11]||(s[11]=r("",7))])}const O=h(E,[["render",o]]);export{j as __pageData,O as default};
